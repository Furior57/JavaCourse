package com.javacode.collections.set;

import java.util.Objects;

public class Car implements Comparable<Car> {
    private final String carBrand;
    private final String model;
    private final Integer pricePerDay;

    public Car(String carBrand, String model, int pricePerDay) {
        this.carBrand = carBrand;
        this.model = model;
        this.pricePerDay = pricePerDay;
    }

    public String getCarBrand() {
        return carBrand;
    }

    public String getModel() {
        return model;
    }

    public int getPricePerDay() {
        return pricePerDay;
    }

    @Override
    public String toString() {
        return "Car: " + carBrand + ", model: " + model + ", price per day: " + pricePerDay;
    }

    // Имплементация equals() hashCode()

    // equals() по умолчанию
    // сравнивает ссылки на обьекты, если это примитивный тип данных
    // например int, то помня устройство java мы знаем что при создании
    // переменной которая уже равна раннее созданой переменной ide не
    // будет выделять память под новый обьект, а будет ссылаться на уже
    // существующий и при сравнении вернет True, в случае с
    // пользовательскими обьектами это уже не сработает, здесь
    // у каждого обьекта свой адрес в памяти и возврат всегда будет
    // false несмотря на то что обьекты имеют одинаковые свойства
    // вручную переопределим equals() для этого нажимаем ctrl+O и выбираем
    // метод который собираемся переопределять
    // важно помнить три свойства при определении equals() вручную
    // рефлексивность - x.equals(x) всегда должно вернуть true
    // симметрия - если x.equals(y) то y.equals(x) всегда должно быть true
    // транзитивность - если x.equals(y)==true а y.equals(z)==true
    // то x.equals(z) всегда должно быть true
    @Override
    public boolean equals(Object obj) {
        // сначала сравним сами обьекты, нет смысла продолжать если
        // мы сравниваем обьект с самим собой
        if (this == obj) {
            return true;
        }
        // если переданный обьект null либо классы обьектов не равны
        // возвращаем false
        if (obj == null || this.getClass() != obj.getClass()) {
            return false;
        }
        // так как у Object obj нет своих полей и методов нам необходимо выполнить
        // cast(приведение типа)
        // вообще в современной ide приведение делается автоматически,
        // но для лучшей читаемости можно сделать так
        Car car = (Car) obj;
        // а теперь сравниваем поля. Там где у нас String
        // мы можем воспользоваться методом equals() который
        // он имплементирует, в случае с int просто сравнение ==
        // либо поменять тип на Integer и тоже использовать equals()
        return this.model.equals(car.getModel()) &&
                this.carBrand.equals(car.getCarBrand()) &&
                this.pricePerDay == car.getPricePerDay();
    }
    // однако как показала практика не смотря на то что мы реализовали
    // сравнение у нас в выводе все равно будет две одинаковых машины
    // для понимания того что случилось необходимо углубиться в теорию
    // методы equals() и hashCode() устроены таким образом, что работают
    // в связке и поэтому имплементируя один метод мы обязаны имплементировать
    // и второй тоже. дело вот в чем. все что в java имеет приставку Hash
    // основано на хеш-таблицах. сама таблица немного отличается от стандартной
    // в ней по каждому индексу расположен так называемый bucket, это
    // по своей сути однонаправленный список. для двух разных обьектов
    // вычисляется хеш-код, если он разный, то обьекты кладутся в разные
    // bucket-ы, если одинаковый(такое вполне возможно), то они кладутся
    // в один bucket. при сравнении обьектов сначала сравнивается
    // хеш-код, если он разный, то дальнейшая проверка не имеет смысла,
    // обьекты разные, однако если он одинаковый, это не дает гарантии
    // что обьекты одинаковые, здесь уже вступает в ход equals() который
    // сравнивает доступные свойства обьектов и уже если они одинаковые
    // тогда признается что обьекты равны. имплементируя только один из
    // методов мы рискуем тем, что никакой ошибки у нас не возникнет, а
    // дальнейшее поведение поведение программы мы никак не можем предсказать.
    // в нашем случае мы смогли записать два одинаковых обьекта в множество
    // которое по определению не может их записать.

    // имплементируем хеш-код
    // здесь тоже есть правило
    // при повторном вычислении хеш кода обьекта он ВСЕГДА должен совпадать,
    // иначе мы не найдем свой обьект
    @Override
    public int hashCode() {
        // воспользуемся здесь тернарным оператором
        // все что идет перед ? это условие после ? возврат какого то значения
        // если условие верно то вернется значение перед :, иначе -
        // после :. помним что логический 0 это false
        // определяем переменную в которой будет храниться хеш-код
        int result = 31 * (carBrand != null ? carBrand.hashCode() : 0);
        // а теперь по очереди плюсуем хеш код всех полей
        // не забывая умножать result на простое число, обычно 29 или 31
        result = 31 * result + (model != null ? model.hashCode() : 0);
        result = 31 * result + (pricePerDay != null ? pricePerDay.hashCode() : 0);
        return result;
    }


    @Override
    public int compareTo(Car car) {
        // для краткости кода мы можем воспользоваться
        // методом compareTo() класса Integer который
        // так же имплементирует интерфейс Comparable
        // либо написать его вручную, я воспользуюсь тернарным оператором
        return (pricePerDay < car.pricePerDay ? -1 :
                pricePerDay == car.pricePerDay ? 0 : 1);

    }
}
