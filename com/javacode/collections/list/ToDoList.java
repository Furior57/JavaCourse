package com.javacode.collections.list;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

public class ToDoList {
    // List параметризированный класс(на самом деле интерфейс),
    // то есть при создании переменной типа list мы в параметрах
    // должны(на самом деле не должны, но желательно) указать
    // какого типа эта переменная, затем мы указываем к какой именно реализации
    // интерфейса мы обращаемся, здесь мы создаем новый обьект типа ArrayList
    // важно помнить что List это упорядоченный(ordered) тип
    // то есть в каком порядке мы добавляем элементы в таком они и хранятся
    // скорость доступа к элементам такого массива составляет O(1)
    // здесь я изменил ArrayList на LinkedList для реализации метода ниже
    // Но в памяти держим что тут ArrayList :)
    private List<String> toDoList = new LinkedList<>();
    // добавляем элемент с помощью add()
    // здесь мы воспользуемся другим методом который будет
    // записывать задачи в алфавитном порядке но вообще тут
    // в фигурных скобках должно быть написано toDoList.add(task)
    public void addToList(String task) {
        addAlphabetOrder(task);
    }
    // передаем элемент в определенный индекс при этом все элементы
    // сдвигаются вправо, допустим мы передали новый элемент в индекс 5
    // тот элемент который был там раньше получит новый индекс 6
    // и так по цепочке, скорость такой операции O(N) где N кол-во
    // элементов массива.
    public void addToListAtPosition(int position, String task) {
        toDoList.add(position, task);
    }
    // с помощью метода get() обращаемся к элементам списка
    public void printToDoList() {
        for (int i = 0; i < toDoList.size(); i++) {
            System.out.println(i+" "+toDoList.get(i));
        }
    }
    // меняем элемент по индексу с помощью set(), при этом элемент
    // именно заменяется, никакого сдвига не будет
    public void insertTask(int index, String task) {
        toDoList.set(index, task);
    }
    // удаляем элемент с помощью remove() при этом мы можем передать
    // как сам обьект который удаляем, так и индекс который удаляем
    public void removeTask(String task) {
        toDoList.remove(task);
    }// перегрузим функцию
    public void removeTask(int index) {
        toDoList.remove(index);
    }

    // получаем номер индекса элемента с помощью indexOf()
    public int getTaskPriority(String task) {
        return toDoList.indexOf(task);
    }

// При создании ArrayList его размер по умолчанию составляет 10,
// под это выделяется память и если мы вставляем какой то элемент со
// сдвигом то память рядом уже может быть занята, поэтому весь массив копируется
// и переносится в другое место в памяти где свободного места достаточно
// такая операция занимает довольно продолжительное время.
// Для того чтобы избежать этого используется LinkedList, по своей сути это
    // двусвязный список, каждый элемент в нем содержит ссылку на следующий
    // элемент и на предыдущий элемент, скорость доступа к эелементам
    // соответственно O(N) где N количество элементов в массиве,
    // однако скорость вставки элемента в массив O(1), что много удобней
    // чем в ArrayList. Так же LinkedList может быть односвязным.
    // создаем обьект LinkedList
    private LinkedList<String> toDoLinkedList = new LinkedList<>();
    // продолжение в классе LinkedListRealisation

    // данный метод будет добавлять задачи в список в алфавитном порядке
    // boolean он для того чтобы делать возврат и завершать выполнение
    private boolean addAlphabetOrder(String task) {
        // инициализируем обьект listIterator
        ListIterator<String> listIter = toDoList.listIterator();
        while (listIter.hasNext()) {
            // метод compareTo() сравниваем обьекты которые в него передали
            // если он возвращает 0, то обьекты равны
            // если значение больше чем 0 то переданный параметром
            // обьект больше чем тот с которым сравниваем
            // если меньше нуля то переданный обьект меньше того
            // с которым сравниваем
            int compered = listIter.next().compareTo(task);
            // выводим сообщение о том что такая задача уже существует
            if (compered == 0) {
                System.out.println("Task is already exist");
                return true;
                // если вызывающий обьект оказался больше обьекта который
                // хотим записать то передвигаем каретку назад методом
                // previous() и записываем обьект
            } else if (compered > 0) {
                listIter.previous();
                listIter.add(task);
                return true;
            }// здесь нет блока else так как если если вызывающий обьект
            // меньше вызываемого, то мы ничего не делаем
         // особое внимание к тому что внутри цикла мы пользуемся для записи
         // listIter.add() а вне его обращаемся напрямую к списку
         // это связано с тем,
            // что при работе с итератором внутри него есть переменная
            // modCount которая считает все изменения сделанные в списке
            // и если мы модифицируем список напрямую, то
            // expectedModCount не будет совпадать с modCount
            // что вызовет исключение. Сначала надо завершить работу с итератором
            // либо пользоваться его методами для модифицирования списка

            // записываем обьект в список если он больше вызываемого обьекта
            // либо если список изначально был пустой, здесь уже напрямую
            // так как работу с итератором мы завершили
        }toDoList.add(task);
        return true;
    }


}
