package com.javacode.lambdas;

import java.util.Arrays;
import java.util.Comparator;

public class LambdasMain {
    public static void main(String[] args) {
        String[] colours = {"green", "brown", "black", "pink", "grey"};

        Players player1 = new Players("Art", 3500);
        Players player2 = new Players("Alex", 4800);
        Players player3 = new Players("Viktor", 2800);
        Players player4 = new Players("John", 91);

        Players[] players = {player1, player2, player3, player4};

        // Приступаем к новой теме, лямбда-выражения
        // Мы имеем некий массив String в котором у нас лежат цвета
        // и имеем второй массив в котором лежат обьекты Players
        // мы хотим отсортировать оба этих массива, если у массива String
        // мы можем это сделать сразу, так как тип String имплементирует
        // интерфейс Comparable,
        Arrays.sort(colours);
        // то с Players все не так просто
        // мы будем использовать тот же метод, но помимо массива мы
        // должны передать компаратор который тут же и реализуем с помощью
        // анонимного класса, ide автоматически создаст метод compare()
        // который необходимо переопределить, сортировать будем
        // по количеству очков
//        Arrays.sort(players, new Comparator<Players>() {
//            @Override
//            public int compare(Players p1, Players p2) {
//                // для этого просто вычтем из очков первого игрока
//                // очки второго игрока, сортировка будет по возрастанию
//                return p1.getScore() - p2.getScore();
//            }
//        });
        // точно так же если мы хотим сортировать наши строки не стандартным
        // методом мы используем анонимный класс
//        Arrays.sort(colours, new Comparator<String>() {
//            @Override
//            public int compare(String s1, String s2) {
//                // здесь мы сортируем по последней букве строки,
//                // вывод так же от меньшего к большему
//                return s1.charAt(s1.length()-1)-s2.charAt(s2.length()-1);
//            }
//        });
        // подобный подход неудобен тем что анонимный класс создается только
        // один раз при выполнении выражения, для нового выражения нужен будет
        // новый анонимный класс, мы конечно можем вынести это все в отдельный класс
        // компаратор, но в этом есть смысл только в том случае если мы будем использовать его
        // множество раз и не можем обойтись лямбда выражением

        // лямбда выражение - это анонимное обьявление функции в любом месте кода,
        // оно не имеет модификатора доступа, возвращаемого значения и имени, проще говоря
        // мы пишем метод и сразу используем его, без выноса в отдельное поле, это
        // позволяет быстрее писать код, там где функция вызывается лишь однажды и
        // сильно упрощает чтение кода, синтаксис лямбда-выражений такой:
        // (параметры)->(тело), количество параметров может быть от 0 и более, тип
        // параметров можно указать явно, а можно получить из контекста,
        // параметры заключаются в круглые скобки и разделяются запятыми
        // если параметров нет - используются пустые скобки, если параметр
        // только один, можно вообще не использовать скобки
        // тело лямбда-выражения может содержать от 0 и более выражений
        // если тело состоит из одного оператора - его можно не заключать в фигурные
        // скобки и не указывать ключевое слово return
        // в противном случае фигурные скобки обязательны(блок кода), а в конце
        // указывается возвращаемое значение с использованием return, если возврата нет
        // указывается return void
        // теперь вооружившись теорией напишем лямбда-выражение для сравнения строк

        // простейший вариант, мы просто копируем аргументы метода compare, и его
        // тело и ставим -> между ними, вуаля, мы прекрасны и написали
        // первое лябда-выражение, но это далеко не самое лучше написание, сократим
        // его вспомня все правила которые записывали
        // теперь все уместилось в одной строке
        Arrays.sort(colours, (s1, s2) -> s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));
        System.out.println(Arrays.toString(colours));
        // теперь перепишем сравнение наших игроков используя if-else statement
        // здесь несколько сложнее, так как мы имеем больше чем одно выражение, то всю
        // эту конструкцию заключаем в фигурные скобки, а дальше просто используем if-else
        // если очки равны то мы используем сравнение по имени с методом compareTo()
        Arrays.sort(players, (p1, p2) -> {
            if ((p2.getScore() - p1.getScore() != 0)) {
                return p2.getScore() - p1.getScore();
            } else {
                return p1.getName().compareTo(p2.getName());
            }
        });
        // goTo LambdaExample
    }

    private static class Players {
        private String name;
        private Integer score;

        public Players(String name, Integer score) {
            this.name = name;
            this.score = score;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return "Players{" +
                    "name='" + name + '\'' +
                    ", score=" + score +
                    '}';
        }

        public Integer getScore() {
            return score;
        }

        public void setScore(Integer score) {
            this.score = score;
        }
    }

}
