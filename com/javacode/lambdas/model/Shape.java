package com.javacode.lambdas.model;

import java.util.List;

public interface Shape {
    // познакомимся с дефолтными методами, дефолтный метод имеет модификатор доступа
    // default, его отличие от остальных методов в том что у него уже есть готовая имплементация
    // и переопределять ее не обязательно. Основное преимущество
    // в том что мы можем наследоваться от разных классов и интерфейсов у которых есть
    // дефолтные методы с одинаковой сигнатурой и разной имплементацией
    // здесь мы определим метод calcSomething и заполним псевдокодом
    // и определим такой же метод в классе Ellipse с такой же сигнатурой,
    // дополнительно мы унаследуемся классом Circle от класса Ellipse.
    // что мы имеем в итоге? мы имеем интерфейс в котором есть default метод calcSomething
    // имеем класс Ellipse в котором определен такой же метод и имеем класс Circle
    // который наследует класс Ellipse с этим методом и имплементирует интерфейс
    // Shape в котором этот же метод определен как дефолтный.
    // работает это все так: если у нас есть класс который наследуется от класса в котором
    // уже есть имплементация дефолтного метода, то предпочтение будет отдано методу класса
    // а не методу интерфейса, перейдем в LambdaExample 92

    double calcSquare();

    static double calcShapeSquare(List<Shape> shapes) {
        double squareSum = 0;
        for (Shape shape : shapes) {
            squareSum = squareSum + shape.calcSquare();
        }
        return squareSum;
    }

    default double calcSomething() {
        return 1.3;
    }
}
