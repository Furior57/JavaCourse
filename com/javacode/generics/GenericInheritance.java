package com.javacode.generics;

import java.util.ArrayList;
import java.util.List;

public class GenericInheritance {
    // очень важный момент касается наследования дженериков
    // как мы помним из ооп мы можем присвоить переменной базового класса
    // класс наследник как значение
    Number n = Integer.valueOf(20);
    // пока запомним это и напишем функцию работающую со списком Number
    private static void printElements(List<Number> list) {
        for (Number e : list) {
            System.out.println(e);
        }
    }


    public static void main(String[] args) {
        // создадим список Integer и заполним его
        List<Number> list = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            list.add(i);
        }
        // если мы попробуем использовать нашу функцию для вывода этого
        // листа на экран то получим ошибку компилирования
//        printElements(list);
        // компилятор нам скажет что ожидаемый тип Number а мы ему подсовываем
        // Integer, то есть наследование тут не работает, разбираемся.

        // Для начала создадим свой интерфейс который будет наследоваться от List интрефейса
        // назовем его BoxList, перейдем туда.

        // мы параметризировали класс одним типом, а в конструктор передали еще и второй тип
        // создадим обьект класса
        MyBox<Integer> testBox = new MyBox<Integer>("", 20);
        // как видно несмотря на то что наш класс параметризирован типом Integer, мы все равно
        // передали в него String и никаких ошибок компиляции не возникло, вернемся в класс
        // MyBox на 20 строку
        // вызываем метод который создали, обращаем внимание что мы параметризируем
        // этот метод тем типом который передаем, однако делать это не обязательно
        // ide сама разберется какой тип мы передали, но для простоты чтения кода
        // можно вручную параметризировать вызов метода
        Double aDouble = MyBox.<Double>returnValue(0.03);
        // перейдем в класс GenericMethods на 28 строку

    }






}
