package com.javacode.generics;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class GenericMethods {
    // мы создали класс и метод main в нем, внутри мы определили несколько
    // массивов с разными типами данных и можем перегрузить метод для их вывода
    // на экран, чтобы он умел принимать разные типы данных
    // несмотря на то что перегрузка создана для подобных ситуаций
    // мы все же нарушаем правило "не повторять себя", создадим метод принимающий
    // любые типы данных с помощью generics, перейдем к методу printArray()
    public static void main(String[] args) {
        Integer[] intArray = {1, 0, 3, 8, 5, 7};
        Double[] doubleArray = {0.234, 6.45, 9.456, 1.345, 4.657};
        String[] stringArray = {"asd", "sdf", "fdg", "fge"};

        printArray(intArray);
        printArray(doubleArray);
        printArray(stringArray);

        // теперь определим максимум, мы написали функцию findMax()
        // мы можем передать туда Number[] либо любого из его потомков
        // в данном случае воспользуемся уже созданным массивом Integer
        System.out.println(findMax(intArray));
        // далее разбираемся с наследованием, перейдем в класс GenericInheritance

        // у нас есть метод для вывода всех элементов списка, он параметризирован
        // типом Number, Integer является наследником Number, было бы логично
        // предположить что List<Integer> является наследником List<Number>
        // но с дженериками это работает не так, они инвариативны, просто по той
        // причине что если List<Number> предок и для List<Double>, то мы можем положить
        // Double в List<Integer>, а это по известным причинам невозможно, однако
        // мы можем сделать несколько по другому, у нас уже есть готовый массив
        // сделаем на его основе список
        List<Integer> integers = Arrays.asList(intArray);
        // в таком виде мы все равно не можем передать этот массив в наш метод
        // ибо переменная уже параметризирована типом Integer, однако
        // мы можем напрямую вызвать этот метод в printElements()
        // и все заработает, все потому что метод asList() параметризирован дженерик типом Т
        // и он сам подставит нужный тип данных при компиляции, либо мы можем
        // параметризировать нашу переменную типом Number и тоже спокойно ее передать
        printElements(Arrays.asList(intArray));
        // однако это не самый лучший способ реализации подобной задачи
        // перейдем в класс CompanyMain

    }

    // все просто, после ключевого слова static мы указываем
    // дженерик тип <T>, а аргуметом принимаем массив этого типа
    private static <T> void printArray(T[] intArray) {
        System.out.println("Generic method called");
        for (T element : intArray) {
            System.out.printf("%s ", element);
        }
        System.out.println();
    }

    // мы так же можем типом возврата функции указывать этот дженерик тип
    // здесь мы будем искать максимум, для сравнения данный мы
    // будем пользоваться методом compareTo()
    // для этого при обьявлении функции укажем что наш тип T наследуется
    // от интерфейса Comparable который тоже параметризирован типом T,
    // теперь мы можем пройтись циклом по массиву и записать максимальное
    // значение в переменную которую мы и вернем
    // мы можем наследовать не только интерфейс, но и класс, напоминание,
    // мы можем наследоваться только от одного класса и от любого количества
    // интерфейсов, в данном случае при наследовании от интерфейса так же
    // пишем extends, а не implements, здесь наследуемся от класса Number
    // он родитель для всех числовых типов данных и после класса через символ &
    // указываем интерфейсы которые тоже наследуем, & ставим после каждого интерфейса,
    // теперь наша функция может работать только с числовыми значениями
    private static <T extends Number & Comparable<T>> T findMax(T[] array) {
        T max = array[0];
        for (T e : array) {
            if (e.compareTo(max) > 0) {
                max = e;
            }
        }
        return max;
    }

    // служебный метод для вывода элементов списка
    private static void printElements(List<Number> list) {
        for (Number n : list) {
            System.out.println(n);
        }
    }
}
