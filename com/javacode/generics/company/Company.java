package com.javacode.generics.company;

import com.javacode.generics.company.employees.Employee;
import com.javacode.generics.company.employees.ITSpecialist;

import java.util.ArrayList;
import java.util.List;

public class Company {
    // итак мы имеем параметризированный класс Department а в этом классе мы имеем метод
    // для создания департаметов, но у нас остается две проблемы, во первых - сейчас этот
    // метод принимает непараметризированный класс, а во вторых при создании инстанса
    // Department мы можем параметризировать его абсолютно любым типом, например String
    // и создать несуществующий департамент, чтобы исправить это мы установим границы класса
    // сейчас можно зайти в Department и посмотреть как мы его параметризировали
    // теперь перейдем к методу addDepartment, при обьявлении метода мы установили
    // границы, в данном случае верхнюю, что означает что все типы которые мы передаем
    // в этот метод должны быть либо Employee либо его потомками, по русски это значит
    // что раз мы параметризируем департамент каким то типом сотрудников, то это
    // должны быть именно сотрудкини ,а не другой тип goTo 29
    private List<Department> departments = new ArrayList<>();
    private List<Employee> employees = new ArrayList<>();

    public <T extends Employee> void addDepartment(Department<T> dep) {
        departments.add(dep);
        List<T> employeeList = dep.getEmployees();
        giveRise(employeeList);
        this.employees.addAll(employeeList);
    }
    // этот метод позволяет поднять сотруднику зарплату, для того чтобы он адекватно принял
    // список сотрудников в методе addDepartment() мы должны его так же параметризировать
    // но здесь мы воспользуемся так называемой wildcard, wildcard это термин из покера
    // чаще всего он означает джокера, в нашем случае мы ставим ? и пишем что он
    // расширяется классом Employee, то есть нечто наследуется от этого класса
    // заранее не известно какой именно тип это будет, но мы установили верхнюю
    // границу, это нечто может быть любой коллекцией которая содержит в себе
    // Employee и его подтипы, однако это накладывает ограничения, мы можем подобным
    // образом только читать обьекты, но не можем их записать в коллекцию(исключение null)
    private void giveRise(List<? extends Employee> list) {
        for (Employee e : list) {
            float v = e.getSalary() * 0.2f;
            e.setSalary(e.getSalary() + v);
        }
    }

    // мы рассмотрели bounded wildcard, то есть с границей, теперь рассмотрим unbounded
    // вариант, он может пригодиться если мы используем методы класса Object
    // либо если мы работаем с коллекцией, допустим List и хотим использовать метод size()
    // нам в этот момент неважно какой тип находится в списке
    public void print(List<?> list) {
        System.out.println("Size "+ list.size());
        System.out.println(list);
    }
    //goTo CompanyMain 35

    // теперь рассмотрим обратную ситуацию, мы хотим использовать в коллекции какой то тип
    // и все родительские типы для него, для этого мы параметризируем коллекцию
    // таким образом <? super SomeType), теперь мы можем использовать только этот тип
    // и всех его предков, это снова накладывает на нас ограничение, мы можем записывать
    // любые типы в пределаех границ в нашу коллекцию, однако читать мы можем только тип
    // Object, в Main методе мы вызовем этот метод, а сами перейдем вниз за границы класса
    public void addToITEmployees(List<? super ITSpecialist> list) {
        list.add(new ITSpecialist("Jo-Jo", 3500.0f));
    }

    public List<Department> getDepartments() {
        return departments;
    }

    public List<Employee> getEmployees() {
        return employees;
    }

    @Override
    public String toString() {
        return "Company{" +"\n"+
                "departments=" + departments +"\n"+
                ", employees=" + employees +
                '}';
    }
}
// итак, немного подробнее об ограничениях при использовании bounded wildcards,
// для более простого запоминания ограничений используется аббревиатура PECS -
// Producer-extends, Consumer-super, то есть то что мы ограничиваем по верхнему краю
// может только предоставлять информацию, а то что мы ограничиваем по нижнему краю
// может ее только потреблять
// однако есть неочевидная вещь, по идее из <? extends SomeClass> мы должны получить
// любого потомка SomeClass, ведь он может содержать либо этот класс, либо его потомков
// но на практике мы можем получить из такой коллекции только
// сам класс и его суперклассы, все дело в том что компилятор изначально не знает
// какой тип будет содержаться в коллекции и может получиться такая ситуация что мы
// положили туда обьекты класса SomeClass и пытаемся получить их в переменную
// класса-потомка, чего конечно же делать нельзя, мы можем обойти это ограничение
// явным приведением типа, плавно переходим к тому почему нельзя ничего записать в такую
// коллекцию. мы уже усвоили что можем обращаться либо к SomeClass, либо к его
// суперам, соответственно положить туда обьект класса предка все равно что
// попытаться положить в List<Integer> обьект Number, компилятор просто не даст этого сделать
// теперь перейдем к Consumer-super, почему мы можем туда положить какие то обьекты?
// а мы уже узнали выше почему, используя extends мы не уверены что там лежит, сам класс
// или его потомок, однако используя super, мы точно уверены что ничего ниже по
// иерархии чем SomeClass там лежать не может, поэтому мы можем записать туда как этот
// класс, так и всех его потомков, а предков записать нельзя
// все потому же почему нельзя записать в List<Integer> обьект Number

// подытожим, в коллекции параметризированные <? extends Number> можно передавать любые
// коллекции потомки класса Number, однако читать оттуда можно либо Number либо его
// предка Object, а записывать только null
// в коллекции параметризированные <? super Integer> можно записывать только
// тип Integer, либо его предков, а получить можно только Object, так как он является
// предком для всех типов в java

// теперь перейдем к еще одной важной теме. Ковариативность, контрвариативность и
// инвариативность
// Ковариативность это сохранение иерархии наследования, то есть если Кошка - наследник
// Животные, то Множество<Кошки>, это подтип Множество<Животные> и мы можем сделать
// присвоение Множество<Животные> = Множество<Кошки>, массивы в Java ковариантны(это не ошибка
// употребляются оба выражения, ковариантны и ковариативны)
// Контрвариативность - это обращение иерархии наследования на противоположную
// Множество<Кошки> = Множество<Животные>
// Инвариативность - это отсутствие наследования между производными типами
// несмотря на то что Кошка наследник Животные Множество<Кошек> не является
// наследником Множество<Животные>, дженерики в Java инвариантны, как раз таки для
// этого используется wildcard:
// Это ковариантность. List<Integer> — подтип List<? extends Number>
// Это контравариантность. List<Number> является подтипом List<? super Integer>
// если нам необходимо и читать и записывать в контейнер, то использовать
// wildcard нет необходимости
