package com.javacode.concurrency.waitNotify;


import com.javacode.concurrency.threadLesson.ColorScheme;

import static com.javacode.concurrency.threadLesson.ColorScheme.BLUE;
import static com.javacode.concurrency.threadLesson.ColorScheme.RED;

public class WaitNotifyExample {
    // теперь поподробней разберемся с методами wait() и notify()
    // как мы помним первый приостанавливает работу потока, второй ее возобновляет, но это не совсем
    // точно, на самом деле метод wait() освобождает монитор обьекта и ждет другой поток, пока не
    // будет вызван метод notify(), а метод notify() будит первый поток, который получит от планировщика
    // потоков, так же есть метод notifyAll(), он будит все существующие потоки
    // в какой последовательности потоки будут пробуждаться зависит от конкретной ОС,
    // так же у метода wait() есть перегрузка принимающая в себя long и  запускает поток после
    // определенного количества милисекунд

    public static void main(String[] args) {
        // создаем обьект класса, он будет служить локом и содержать в себе строку
        Message message = new Message();
        // мы вновь создали два иннер класса Producer и Consumer, перейдем в Producer

        // создаем потоки
        new Thread(new Producer(message)).start();
        new Thread(new Consumer(message)).start();
    }

    // первое отличие от прошлого урока, это конструктор класса, в этот конструктор мы будем передавать
    // обьект локом которого будут пользоваться наши классы для синхронизации потоков, у обоих классов
    // конструкторы идентичны, теперь имплементируем метод run() перейдем туда
    private static class Producer implements Runnable {

        private Message message;

        Producer(Message message) {
            this.message = message;
        }

        String[] text = {"Десять прошло.", "Понимаете?", "Десять!", "Как же ж", "поэтам не стараться?",
                "Как", "на театре", "актерам не чудесить?", "Как", "не литься", "лавой демонстраций?",
                "Десять лет —", "сразу не минуют.", "Десять лет —", "ужасно много!", "А мы", "вспоминаем",
                "любую из минут.", "С каждой", "минутой", "шагали в ногу.", "", "Кто не помнит только",
                "переулок", "Орликов?!", "В семнадцатом", "из Орликова", "выпускали голенькова.",
                "А теперь", "задираю голову мою", "на Запад", "и на Восток,", "на Север", "и на Юг.",
                "Солнцами", "окон", "сияет Госторг,", "Ваня", "и Вася —", "иди,", "одевайся!", "",
                "Полдома", "на Тверской", "(Газетного угол).", "Всю ночь", "и день-деньской —",
                "сквозь окошки", "вьюга.", "Этот дом", "пустой", "орал", "на всех:", "— Гражданин,", "стой!", "Руки вверх! —",
                "Не послушал окрика,—", "от тебя —", "мокренько.", "Дом —", "теперь:", "огня игра.",
                "Подходи хоть ночью ты!", "Тут", "тебе", "телеграф —", "сбоку почты.", "Влю-", "блен",
                "весь-", "ма —", "вмес-", "то", "пись-", "ма", "к милке", "прямо", "шли телеграммы.", "На Кузнецком",
                "на мосту,", "где дома", "сейчас", "растут,—", "помню,", "было:", "пала", "кобыла,", "а толпа", "над дохлой",
                "голодная", "охала.", "А теперь", "магазин", "горит", "для разинь.", "Ваня", "наряден.",
                "Идет,", "и губа его", "вся", "в шоколаде", "с фабрики Бабаева.", "", "Вечером", "и поутру,",
                "с трубами", "и без труб —", "подымал", "невозможный труд", "улиц", "разрушенных",
                "труп.", "Под скромностью", "ложной", "радость не тая,", "ору", "с победителями",
                "голода и тьмы:", "— Это —", "я!", "Это —", "мы!", "DONE"};

        // здесь мы просто вызываем метод produce() и обрабатываем исключения
        @Override
        public void run() {
            try {
                produce();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // а здесь основная работа, мы хотим в этот раз чтобы наши потоки были синхронизированны,
        // для этого мы оборачиваем все наши действия оператором synchronized и в нем запускаем forEach
        // где выводим сообщение со строкой которую используем, записываем в обьекте Message поле с помощью
        // метода setMessage(), после того как мы его записали нам нужно приостановить работу потока
        // до тех пор пока Consumer не прочтет это поле
        private void produce() throws InterruptedException {
            synchronized (message) {
                for (String s : text) {
                    System.out.println(BLUE + "Producing message " + s);
                    message.setMessage(s);
                    // уведомляем следующий поток что он может пробудиться, метод вызываем
                    // на обьекте чьим монитором пользуются наши потоки
                    message.notify();
                    // продолжаем работу до тех пор пока в строке не будет "DONE"
                    if (!"DONE".equals(s)) {
                        // приостанавливаем работу потока Producer
                        message.wait();

                    } else return;

                }
            }
        }
    }

    // здесь аналогичная реализация и та же конструкция где сначала идет notify() а за ним wait()
    // возвращаемся в main()
    private static class Consumer implements Runnable {

        private final Message message;

        Consumer(Message message) {
            this.message = message;
        }


        @Override
        public void run() {
            try {
                consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void consume() throws InterruptedException {
            // запескаем бесконечный цикл
            while (true) {
                synchronized (message) {
                    System.out.println(RED + "Consuming message " + message.getMessage());
                    // пока сообщение не будет DONE продолжаем работу
                    if (!"DONE".equals(message.getMessage())) {
                        // уведомляем следующий поток о пробуждении
                        message.notify();
                        // приостанавливаем работу потока Consumer
                        message.wait();
                    } else return;
                }
            }
        }
    }


}
