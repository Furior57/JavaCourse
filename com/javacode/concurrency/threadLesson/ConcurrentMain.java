package com.javacode.concurrency.threadLesson;


public class ConcurrentMain {
    public static void main(String[] args) {
        // итак мы добрались до потоков и параллельности
        // до этого в интерфейсе Stream я называл открытый стрим потоком, но это неправильно
        // что такое поток? поток - это единица реализации програмного кода, то есть это какая то
        // последовательность действий и данных которая работает параллельно с такими же потоками,
        // все потоки обьединяются в процесс. Процесс это совокупность кода и данных обьединенных
        // общим виртуальным адресным пространством, процессы изолированы друг от друга и доступ
        // к памяти чужого процесса невозможен.

        // Итак начнем знакомство с многопоточностью
        // мы определили класс ColorScheme в котором указали нестолько стринг полей, к каждому полю
        // приписан свой цвет, это необходимо для того чтобы наглядно демонстрировать работу
        // разных потоков

        // Для создания отдельного потока в java есть отдельный класс Thread, этот класс имплементирует
        // интерфейс Runnable в котором есть только один метод run(), мы определили внутренний класс
        // SimpleThread, перейдем в него(был вынесен во внешний класс)
        // создаем инстанс нашего класса
        SimpleThread thread1 = new SimpleThread();
        // запускаем поток с помощью метода start() класса Thread, без этого метода поток не запустится
        thread1.start();
        // теперь выводим какое то сообщение
        System.out.println(ColorScheme.PURPLE + "Hello from main()");
        // и запускаем второй поток
        SimpleThread thread2 = new SimpleThread();
        thread2.start();
        // мы наглядно видим что очередность вывода сообщений от разных потоков не гарантирована
        // иногда первый поток выводит два сообщения подряд, иногда второй, все зависит от того
        // сколько ресурсов получает каждый поток, теперь изучим еще один способ создания потоков,
        // он будет более правильным, перейдем в класс SimpleRunner
        // мы создаем инстанс класса Thread, в конструктор он должен принять интерфейс Runnable,
        // мы туда передадим конструктор нашего класса имплементирующего этот интерфейс
        Thread thread3 = new Thread(new SimpleRunner());
        thread3.start();
        // важный момент, если мы запустим поток из метода run(), мы не создадим новый поток, мы
        // просто запустим этот метод в потоке метода main(), для запуска нового потока используется
        // именно start()
        // так как интерфейс Runnable является функциональным интрефейсом, мы можем передать
        // в конструктор Thread какое то лямбда выражение, здесь мы даже не будем присваивать
        // его переменной, просто вызовем сразу на конструкторе метод start()
        new Thread(() -> System.out.println("Hello from lambda Runnable")).start();
        // иногда нам нужно прервать выполнение потока, для этого используется метод interrupt()
        Thread thread4 = new Thread(new SimpleRunner());
        thread4.start();
        // так как у потоков есть задержка, мы сразу наглядно увидим что поток был прерван
        thread4.interrupt();
        // теперь перейдем в класс VolatileMain


    }


    // класс Thread точно так же имплементирует интерфейс Runnable. метод run() отвечает
    // за то, какую логику мы будем запускать, однако наследоваться от этого класса со всеми его
    // методами черевато, сейчас мы создали класс имплементирующий этот интерфейс, в дальнейшем
    // лучше создавать отдельные интерфейсы, вернемся в main:35
    static class SimpleRunner implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println(ColorScheme.YELLOW +
                            "Warning - " + Thread.currentThread().getName() + " was interrupted " + i);
                }
                System.out.println
                        (ColorScheme.BLUE + "RunnableThread " + Thread.currentThread().getName() + " - " + i);
            }
        }
    }

    // Расширим нашим классом класс Thread
    static class SimpleThread extends Thread {
        // Нам необязательно переопределять методы класса Thread, но мы переопределим метод run()
        // в котором укажем какие действия должен сделать наш поток, напоминание, этот метод
        // принадлежит интерфейсу Runnable


        @Override
        public void run() {

            // мы запустим цикл делающий 10 итераций, обращаемся к текущему потоку с помощью метода
            // currentThread(), выводим имя потока методом getName() и в конце выводим номер итерации
            for (int i = 0; i < 10; i++) {
                // этот метод приостановит выполнения действий в потоке на 1 секунду
                // что замедлит вывод на экран и мы сможем наглядно видеть как работает цикл
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // обратим внимание каким методом мы меняем цвет сообщения в консоли,
                    // это не критично, но лучше запомнить
                    // в случае прерывания потока(Interruption) мы выкинем сообщение
                    // и с помощью ключевого слова return завершим его работу
                    System.out.println(ColorScheme.YELLOW + "Warning - " + currentThread().getName()
                            + " was interrupted " + i);
                    return;
                }
                System.out.println
                        (ColorScheme.GREEN + "INFO - " + currentThread().getName() + " - " + i);
            }
            // эта конструкция проверяет не был ли прерван поток, если он был прерван
            // мы закрываем его, а можем открыть заново, как нам будет нужно, она не должна
            // располагаться на этот месте, но мы просто обозначим ее
            if (Thread.interrupted()) {
                return;
            }
            // вернемся в main()
        }
    }
}
