package com.javacode.concurrency.synch;

import java.util.ArrayList;
import java.util.List;

public class SynchronizedBlock {
    // у нас есть два массива с числами и два пустых списка
    private int[] a = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    private int[] b = {0, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    private List<Integer> intList1 = new ArrayList<>();
    private List<Integer> intList2 = new ArrayList<>();

    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    // в этом примере мы будем вручную указывать где включать и отключать блоки, то есть мы будем
    // ориентироваться не на обьект(this) и не на класс(.class), а сами выбирать блоки коды которые
    // будем блокировать, создадим метод copy(), перейдем в него
    public static void main(String[] args) {
        SynchronizedBlock sb = new SynchronizedBlock();
        sb.copy();
    }

    // этот метод будет нестатическим, то есть для его вызова нам нужно обратиться к инстансу класса в котором
    // написан этот метод, даже внутри самого класса.
    private void copy() {
        // здесь мы создаем потоки и засекаем время их выполнения
        // так же мы создали два вспомогательных метода которые копируют наши массивы в списки, по методу
        // на каждый массив

        // сначала засечем время на начало выполнения инструкций, сделаем это с помощью системного времени
        long start = System.currentTimeMillis();
        // запустим потоки
        Thread thread1 = new Thread(new RunnerA());
        Thread thread2 = new Thread(new RunnerB());
        thread1.start();
        thread2.start();
        try {
            // говорим программе, что пока потоки не завершат работу она не должна продолжаться
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        long end = System.currentTimeMillis();
        long time = end - start;
        // сейчас потоки будут отрабатывать случайно, но есть еще один ньюанс, дело в том что
        // вывод времени работы потоков произойдет сразу, то есть нам посчитает время 4ms, а потоки
        // продолжат работать, чтобы этого не случилось необходимо воспользоваться методом
        // Thread.join(), он отложит выполнение программы до тех пор пока поток не завершит работу
        // пропишем сначала его, он выбрасывает исключение прерывания, поэтому обернем в try-catch,
        // теперь все работает в соответствии с нашими ожиданиями и время работы потоков составляет
        // примерно 1200ms, а теперь пометим наши методы с копированием как synchronized,
        // сначала отработает первый поток, потом второй, при этом время работы потоков
        // увеличится почти в два раза. происходит это потому, что у каждого обьекта в java
        // есть так называемый mutex, это некая сущность которая отвечает за блокировку обьекта
        // после того как мы пометили метод как synchronized, мы запретили одновременное использование
        // обьекта разными потоками, в нашем случае обьект это инстанс класса SynchronizedBlock на котором
        // мы вызываем метод copy(), первый поток добравшийся до mutex, захватывает его и второй поток
        // вынужден ждать пока первый завершит работу.

        // чтобы решить эту проблему мы можем поступить несколькими способами. Первый и самый простой, это
        // вызывать методы на разных инстансах класса, однако наш код написан так чтобы мы не могли
        // этого сделать, с другой стороны если бы наш метод был статическим, то мы всегда обращались
        // бы не к самому инстансу, а к классу и делали блокировку на уровне класса.
        // мы поступим по другому, мы можем обернуть блок кода с помощью оператора synchronized, выглядеть это
        // будет так:
//        synchronized (obj) {
//            someCode
//        }
        // в скобки мы передаем ссылку на обьект, это будет обьект блокировки, помечая сам метод
        // как synchronized мы тоже неявно пользуемся этой записью, в скобки передается this - если
        // метод вызван инстансом, либо .class - если метод вызван классом.
        // Мы заведем два обьекта класса Object, которые и передадим в эти скобки, у каждого метода после
        // этого будет свой mutex и они спокойно отработают параллельно, закомментируем старые методы
        // и напишем новые. теперь все потоки действительно параллельно работают.
        System.out.println("Time taken: " + time + "ms");

        // подытожим и немного углубимся в теорию. в ходе данной лекции я использовал термины мьютекс
        // и монитор, это немного разные сущности, но если кратко, их можно описать так: мьютекс - это
        // некая сущность которая видит что к обьекту подключился поток и запрещает другим потокам
        // использовать этот обьект, а монитор - это блок кода который выполняется при блокировке,
        // я могу быть неправ, далее подробней изучу тему и вернусь для правки, если она потребуется.
        // также есть понятие семафора, чтобы его лучше понимать необходимо почитать задачу о
        // пяти философах и лапше, мы же просто кратко его опишем, семафор - это некая сущность
        // в которой указано сколько потоков может подключиться к данному обьекту, в нем есть
        // специальный счетчик, который уменьшается на 1 когда подключается поток, мьютекс называют
        // бинарным семафором, потому что у него этот счетчик равен 1, соответственно
        // доступ либо есть, либо нет.
        // у каждого обьекта в java есть свой мьютекс, поэтому при использовании оператора
        // synchronized(){} мы передаем в него ссылку на обьект, чей мьютекс будет взят, в нашем примере
        // мы создавали два инстанса Object, чтобы позволить разным потокам работать параллельно, но
        // мы сами загнали себя в эти рамки вызывая наши методы из одного обьекта, в работе лучше
        // обходить такие моменты и писать код который масштабируется на любое количество обьектов(потоков)



    }

    // эти два метода копируют содержимое массивов в списки и приостанавливают поток на 0.1 секунды
    // ниже мы определили классы имплементирующие Runnable, для каждого массива свой, она вызывают
    // в себе наши методы copyArrayX(), а теперь вернемся в метод copy()
//    private synchronized void copyArrayA() {
//        for (int i = 0; i < a.length; i++) {
//            intList1.add(a[i]);
//            System.out.println(intList1);
//            try {
//                Thread.sleep(100);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//
//        }
//    }
//
//    private synchronized void copyArrayB() {
//        for (int i = 0; i < b.length; i++) {
//            intList2.add(b[i]);
//            System.out.println(intList2);
//            try {
//                Thread.sleep(100);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//
//        }
//    }
    // такая запись гарантирует параллельность работы наших потоков, не забываем убрать слово
    // synchronized из сигнатуры метода, иначе ничего не изменится
    private void copyArrayA() {
        synchronized (lock1) {
            for (int i = 0; i < a.length; i++) {
                intList1.add(a[i]);
                System.out.println(intList1);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }

    private void copyArrayB() {
        synchronized (lock2) {
            for (int i = 0; i < b.length; i++) {
                intList2.add(b[i]);
                System.out.println(intList2);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }

    private class RunnerA implements Runnable {
        @Override
        public void run() {
            copyArrayA();
        }
    }

    private class RunnerB implements Runnable {
        @Override
        public void run() {
            copyArrayB();
        }
    }


}
