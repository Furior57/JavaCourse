package com.javacode.concurrency.synch;

import javax.xml.transform.TransformerException;

public class FibonacciConcurrent {
    private static int previous = 0;
    private static int current = 1;
    public static void main(String[] args) {
        // мы изуличи ключевое слово volatile и узнали для чего оно нужно, если кратко, это слово
        // позволяет делать операции с переменными атомарными(неделимыми) и наши потоки всегда видят
        // в памяти актуальное значение. но сохраняется другая проблема, доступ к переменным, у нас
        // может возникнуть ситуация когда несколько потоков одновременно захотят получить к ней доступ,
        // в этому случае у нас нет гарантий что код будет выполняться последовательно инструкция за
        // инструкцией, в соответствии с тем какую логику мы заложили.
        // чтобы избежать этой проблемы используется ключевое слово synchronized

        // воспроизведем ситуацию когда код будет работать некорректно.
        // для примера мы будем вычислять числа Фибоначчи, напоминание, числа Фибоначчи - это
        // последовательность чисел, где каждое число равно сумме двух предыдущих чисел.

        // для начала определим две глобальных переменных previous и current и создадим метод
        // который будет в консоль выводить сумму этих переменных, назовем calcNext, перейдем к нему

        // теперь создадим два потока которые будут вызывать FibonacciRunner и запустим их
        Thread th1 = new Thread(new FibonacciRunner());
        Thread th2 = new Thread(new FibonacciRunner());
        th1.start();
        th2.start();
        // не будем писать здесь вывод, просто поверим на слово, что при каждом запуске последовательность
        // будет разной, иногда даже правильной. чтобы избежать такого результата, нам необходимо
        // блокировать метод если его уже использует какой то поток, делается это ключевым
        // словом synchronized поторое мы пропишем перед типом возврата в обьявлении метода.

        // поговорим поподробней о том как именно происходит блокировка.
        // если мы уберем слово static из обьявления нашего метода, то произойдет блокировка
        // обьекта к которому обращается поток, то есть блокировка this.Object, а если мы его оставим
        // то произойдет блокировка класса, выглядеть это будет так
//        synchronized (FibonacciRunner.class) {
//            someCode
//        }
        // то есть мы можем использовать это слово не только при обьявлении метода, класса и т.д.
        // но и для блокировки определенного блока кода, обернув его в блок synchronized
        // перейдем в класс SynchronizedBlock


    }
    // все что он делает это складывает значения наших переменных и обновляет их до текущих значений
    private static synchronized void calcNext() {
        int next = previous+current;
        previous = current;
        current = next;
        System.out.println(current);
    }

    // теперь определим класс имплементирующий Runnable, он будет в цикле вызывать метод
    // calcNext(), вернемся в метод main()
    private static class FibonacciRunner implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                calcNext();
            }
        }
    }
}
